
# Static Analysis (High Level) Workflow Report – mal17.exe

This document details of the high level step taken to statically analyze the suspicious executable **mal17.exe** using various forensic and reverse engineering tools.**(Not all the steps uesd in this analysis was documented in this report,just some of the top level/major breakpoints)**

---

## ⚙️ Environment

- **OS:** Remnux Linux
- **Analysis Type:** Static (Non-execution)
- **Sample:** mal17.exe
- **Goal:** Identify structure, embedded payloads, and obfuscation layers

---

## 🧾 Step 1: Hashing and Threat Verification

### Command
`sha256 mal17.exe`

### Result
`ce28ce80d5f620894c987bcbcf86e858fdc5a1635b8e26457cd87ef99999ef4b`
- **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/file_hash.png) 


### VirusTotal Check
Searched the hash on VirusTotal.**(*Very important,because you wouldnt want to spend hours analysing a non-malacious file*)**

*Result:* **54/72 antivirus vendors flagged it as malicious or trojanized.**

- **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/virusTotalOutput.png) 

---

## 🧩 Step 2: Identify File Type

### Command
`file mal17.exe`

### Output
`mal17.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows`
- **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/file.png) 


🧠 **Interpretation:** The binary is a .NET (VB.NET) Windows application — ideal for decompilation and code inspection.

---

## 🔍 Step 3: Extract Readable Strings

### Command
`strings -a -n 6 mal17.exe`

🧠 **Purpose:** To locate readable text such as URLs, registry paths, or encoded payloads.

### Findings
- Long Base64 strings
- References to WinRAR
- Paths suggesting Windows Registry interaction
- Possible network-related function calls

- **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/strings.png) 

---

## 🧮 Step 4: Structural Analysis Using Peframe

### Command
`peframe mal17.exe `

### Highlights
- File size: 1.7 MB
- `.text` section entropy: 7.99
- `.rsrc` section entropy: 7.58
- Signs of packing and encryption
- Creates a mutex and uses XOR
- Fake metadata: “WinRAR 64-bit Setup”

  - **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/peframe.png) [`Click here to view`](../../../assets/images/Malware_Analysis/peframe2.png) 


🧠 **Interpretation:** This confirms anti-analysis techniques and packed code sections.

---

## 🧰 Step 5: Embedded Resource Extraction

### Command
`binwalk -e mal17.exe`

### Results
- Extracted 256×256 PNG (likely an icon)
- Extracted XML configuration file
- Detected embedded PE data

  - **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/binwalk.png) 


🧠 **Interpretation:** The malware hides its payloads and configuration inside resources — a classic dropper technique.

---

## 🧩 Step 6: Entropy & Obfuscation Analysis

**Tool:** Detect It Easy (DIE GUI)

### Results
- Type: PE32 VB.NET Executable
- Entropy: 7.99 (heavily packed)
- Obfuscation: 99%
- Packed .text section

  - **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/DiE.png) 


🧠 **Interpretation:** The executable is heavily obfuscated, using compression or encryption to conceal its true code.

---

## 🧠 Step 7: Decompiled Source Inspection

### Command
`ilspycmd -p mal17.exe -o decompiled/`

### Recovered files

       ├── My/
       │ ├── MyApplication.cs
       │ ├── MyComputer.cs
       │ ├── MyProgram.cs
       ├── Properties/
       │ ├── AssemblyInfo.cs
       ├── Program.cs
       ├── app.ico
       ├── Winrar64.csproj
       ├── aotffdzhjsz.resx

- **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/decompliled.png) 


🧠 **Observation:** The project name “Winrar64” confirms disguise. Decompiled code contained multiple Base64 layers and randomized variable names (obfuscation).

---

## 💀 Step 8: Extract and Decode Payload

Inside the decompiled .resx file, a <value> tag held a Base64-encoded payload.

### Command
`base64 -d payload.txt > encrypted.bin`

Then extracted to:
`file decrypted_payload.exe`

### Output
`decrypted_payload.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows`

- **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/decrypting.png) 


🧠 **Interpretation:** The decrypted file is another .NET payload — showing multi-stage loader behavior.

---

## 🧩 Step 9: Decompiled Payload Review

### Command
`ilspycmd -o decompile_payload decrypted_payload.exe`

### Findings
- Contains deep nested calls like:
  `Encoding.UTF8.GetString(Convert.FromBase64String(Encoding.UTF8.GetString(Convert.FromBase64String("..."))));`
  This indicates recursive decoding logic.
- Possible use of XOR encryption in addition to Base64.

- **Evidence:** [`Click here to view`](../../../assets/images/Malware_Analysis/encoding.png) 

---

## 🔐 Step 10: Decryption Attempt

Used CyberChef to:
- Apply “From Base64”
- Apply “XOR Brute Force”
- Analyze for readable plaintext (URLs, domains, registry keys)

🧠 **Finding:** Portions of data appear to be network configuration or loader commands, confirming encrypted C2 data.

---

## 🧠 Summary of Technical Findings

| Category | Details |
|---|---|
| Type | VB.NET Loader / Dropper |
| Obfuscation | Base64 + XOR + Packing |
| Persistence | Mutex & Registry modifications |
| Disguise | Fake WinRAR metadata |
| Stage 2 Payload | decrypted_payload.exe |
| Likely Goal | Download and execute malicious payload in memory |
| Network IOCs | Possible HTTPS C2 (disguised domains) |

---

## 🧩 Conclusion

This sample acts as a multi-stage VB.NET loader, employing heavy obfuscation, resource embedding, and encrypted payloads to avoid detection. The secondary payload is likely responsible for C2 communication and execution of remote commands.

---

## Note:

All of the commands above were practiced in a sandboxed environment isolated from the host machine.
